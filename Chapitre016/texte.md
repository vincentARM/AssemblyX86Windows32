# Chapitre 16 : saisie de données 

Dans ce chapitre, nous allons manipuler diverses fonctions de l’Api windows pour charger des données dans notre programme. Ces données sont le plus souvent des chaînes de caractères saisies au clavier ou passées dans la ligne de commande. Nous récupérerons aussi les valeurs de clic des boutons affichés dans une fenêtre de message. Mais nous verrons plus tard, la saisie d’une valeur dans une fenêtre windows. <br>
Dans le programme saisieDonnees.asm, nous commençons par la saisie d’une chaîne de caractères au clavier. Nous affichons un message d’accueil puis nous appelons la routine lectureClavier. Cette routine est le pendant de la routine afficherConsole puisqu’il nous faut commencer par récupérer la référence de la console d’entrée (input standard handle) avec la fonction getStdHandle. Puis nous appelons la fonction ReadConsoleA pour lire les caractères tapées au clavier. <br>
Pour fonctionner, cette fonction a besoin, outre le handle de 3 paramètres : l’adresse de la zone de réception de la saisie, la taille de cette zone et l’adresse d’un entier pour stocker le nombre de caractères lus. Pour faciliter le passage à notre routine de ces paramètres, nous utilisons une structure qui décrit ces 3 paramètres et il nous suffit de passer l’adresse d’une instance de cette structure à notre routine.<br>
Lors de l’utilisation des premières fonctions de l’api windows, nous ne nous sommes pas préoccupés des erreurs pouvant être générées par celle ci car en effet si l’affichage d’un message ou dans la console génère une erreur, nous ne pouvons rien faire !!! Ici, il nous faut signaler à l’utilisateur une éventuelle erreur de saisie. Pour cela nous créons une routine afficherErreur qui va formater un message contenant le code erreur windows et la ligne où s’est produit l’erreur. <br>
Formater un message ?  Oui nous avons vu dans le chapitre sur les chaînes de caractères une routine pour insérer une sous chaîne dans une chaîne en pur assembleur. Mais ici nous allons utiliser la fonction wsprintfA à laquelle on passe les valeurs, le libellé du message et la zone réceptrice. <br>
Le libellé contient les descriptifs de formatage %d comme dans la fonction C printf. <br>
Mais attention, comme cette fonction peut accepter un nombre variable de paramètres c’est au programme appelant d’aligner la pile après l’appel. C’est pourquoi nous trouvons l’instruction add esp,16 puisque nous passons à la fonctions 4 paramètres de 4 octets. <br>
Ensuite nous passons le résultat à la fonction MessageBoxA en forçant l’icône d’affichage à MB_ICONERROR. <br>
Revenons au programme principal pour afficher en brut la zone mémoire qui a réceptionné la saisie. 
Nous y trouvons bien la chaîne saisie mais terminée par les caractères 0x0D et Ox0A. Si nous voulons une chaîne correcte il faudra forcer la valeur 0 binaire à la place du 0x0D  grâce au compteur de caractères lus. <br>

Une autre possibilité est de saisir dans la ligne de commande une chaîne de caractère par exemple en tapant dans powershell ./saisieDonnees toto. La fonction de l’Api GetCommandKineA va retourner l’adresse de la ligne de commande complète que nous passons à une routine qui va analyser et extraire chaque paramètre. Les paramètres sont séparés par des espaces et il faut faire attention que cet espace ne soit pas à l’intérieur de guillemets. En effet si vous saisissez ./saisieDonnees toto tutu, il y a 3 paramètres mais si vous tapez ./saisieDonnees « toto tutu » il n’y a que 2 paramètres à prendre en compte.<br>
Enfin le programme se termine avec un exemple d’affichage d’un message avec un choix de 3 boutons Oui Non et Abandon. <br>

Dans le programme suivant trtLigneCommande.asm, à la place d’une routine en assembleur pour séparer les différents paramètres, nous utilisons des fonctions de l’Api windows.
La première GetCommandLineW retourne l’adresse de la ligne de commande comme la fonction GetCommandLineA mais avec des caractères unicode. Cette adresse est passée à la fonction CommandLineToArgW qui va découper la ligne de commande en paramètre mais curieusement cette fonction n’existe qu »en caractère unicode (W) et pas en caractère ansi (A).  <br>
Comme le montre les affichages bruts de la mémoire, le résultat est peu exploitable mais heureusement il existe une fonction qui effectue la conversion des caractères ce qui nous permet d’avoir une chaîne de caractère exploitable. Mais il faudra faire attention aux multiples possibilités de la fonction pour le traitement des caractères accentués. <br> 
