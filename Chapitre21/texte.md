# Chapitre 21 : exemple d’une fenêtre de saisie.

Nous allons repartir du programme précédent pour créer un programme [fenSaisie.asm](https://github.com/vincentARM/AssemblyX86Windows32/blob/main/Chapitre21/fenSaisie.asm) qui pourra vous servir de nombreuses fois. Il ne contiendra qu'une fenêtre avec une zone de saisie, un bouton et une zone d'affichage des résultats. La zone de saisie vous permettra de récupérer un paramètre puis le bouton lancera le calcul ou la procédure que vous voulez tester et la zone d'affichage vous montrera les résultats.<br>
Nous déportons d’abord toutes les constantes necessaires aux fonctions de l’API dans le fichier includeConstantes.inc. <br>
Puis nous repartons de la création d'une fenêtre simple avec la procédure de gestion des événements ou nous testons les codes WM_CREATE, WM_DESTROY, WM_PAINT et WM_COMMAND.<br>
Pour la création, nous ajoutons une zone de saisie simple, un bouton et une fenêtre d'affichage.<br>
Pour cette dernière, nous la créerons avec les paramètres WS_VSCROLL, ES_MULTILINE, ES_AUTOVSCROLL qui permet d'avoir une zone multi-ligne avec un ascenseur vertical ce qui permet d'afficher des résultats qui peuvent être importants.<br>
Nous initialisons la fenêtre avec une chaîne de caractères à blanc par l'envoi d'un message par la fonction SendMessageA.<br>
Et pour faire plus joli, nous allons mettre en place un sous-programme de centrage de la fenêtre principale sur l'écran de l'ordinateur. Nous passons à notre sous programme le handle de notre fenêtre car ce sous programme pourra être copié pour être utilisé ailleurs.<br>
Dans ce sous programme Centrage_fenetre(récupéré sur Internet et un peu adapté), nous récupérons le handle de l'écran par la fonction GetDesktopWindow puis nous cherchons la taille des 2 fenêtres par GetWindowRect. Cette fonction alimente une structure de type RECT qu'il faudra décrire. Nous calculons le positionnement horizontal et vertical de notre fenêtre et nous la déplaçons par la fonction SetWindowPos .<br>
Pour le dessin de la fenêtre (WM_PAINT) nous nous contentons d'afficher le texte « Saisir le texte » par l'appel de la fonction TextOutA.<br>
Ensuite pour le message WM_COMMAND, nous nous contentons de vérifier si le bouton a été appuyé (BN_CLICKED) pour récupérer le contenu de la zone saisie, lancer un traitement et afficher le résultat. Ici nous transformons la chaîne saisie en majuscules par la fonction CharUpperA et nous l'envoyons par SendMessageA à la fenêtre d'affichage.<br>
Pour améliorer notre programme, nous mettons aussi en place le redimensionnement des 2 zones saisie et affichage et le déplacement du bouton si l'utilisateur modifie les dimensions de la fenêtre.<br>
Pour cela nous testons dans le type de message, WM_SIZE qui est envoyé à chaque redimensionnement et nous positionnons les 3 éléments. Pour ce type de message, c'est le 4 ième paramètre (LPARAM en [ebp+20]) passé par Windows à la procédure de gestion des événements de la fenêtre qui contient dans les bits de poids forts la nouvelle largeur et dans les bits de poids faibles la nouvelle hauteur. Après chaque calcul de la nouvelle position ou de la nouvelle taille, nous appelons la fonction MoveWindow qui va positionner chaque élément comme nous le voulons.<br>
Comme vous pouvez le voir à l’exécution, cela fonctionne très bien.<br>
